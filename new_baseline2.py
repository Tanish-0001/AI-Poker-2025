# -*- coding: utf-8 -*-
"""New_Baseline2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MZbJkqBSjC6dw9t-roeo--T50akMgbtY
"""

import random
!pip install eval7
import eval7

class Player:
    def __init__(self, name, money):
        self.name = name
        self.money = money
        self.cards = input(f"Enter hole cards for {name} (e.g., 'Ah Ks'): ").split()
        self.current_bet = 0
        self.total_bet = 0

    def bet(self, amount):
        if amount > self.money:
            raise ValueError(f"{self.name} does not have enough money to bet {amount}")
        self.money -= amount
        self.current_bet += amount
        self.total_bet += amount
        return amount

    def reset_bet(self):
        self.current_bet = 0

class PokerGame:
    def __init__(self, players, starting_money=1000):
        self.players = [Player(name, starting_money) for name in players]
        self.pot = 0
        self.deck = self.create_deck()
        self.current_bet = 0
        self.board = input("Enter board cards (e.g., '2h 3d 4s'): ").split()

    def create_deck(self):
        suits = ['h', 'd', 'c', 's']
        ranks = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']
        return [rank + suit for suit in suits for rank in ranks]

    def shuffle_deck(self):
        random.shuffle(self.deck)

    def deal_community_cards(self, num_cards):
        self.board.extend([self.deck.pop() for _ in range(num_cards)])

    def calculate_win_probability(self, player, opp_bet, opp_money):
        if not player.cards or len(self.board) < 3:
            return random.uniform(0, 1)  # Placeholder for pre-flop estimation

        hole_cards = [eval7.Card(card) for card in player.cards]
        board_cards = [eval7.Card(card) for card in self.board]

        used_cards = set(player.cards + self.board)  # Track used cards
        remaining_deck = [eval7.Card(card) for card in self.create_deck() if card not in used_cards]

        # Dynamic number of trials based on game stage
        trials = 2000 if len(board_cards) < 5 else 5000

        wins = 0
        for _ in range(trials):
            random.shuffle(remaining_deck)
            remaining_board = board_cards + remaining_deck[:5 - len(board_cards)]
            opp_hole = [remaining_deck[5 - len(board_cards)], remaining_deck[6 - len(board_cards)]]

            player_hand = hole_cards + remaining_board
            opp_hand = opp_hole + remaining_board

            if eval7.evaluate(player_hand) > eval7.evaluate(opp_hand):
                wins += 1

        win_prob = wins / trials

        # Adjust probability based on opponent betting
        if opp_money > 0:
            raise_ratio = opp_bet / opp_money
        else:
            raise_ratio = 1  # Assume all-in scenario

        if raise_ratio > 0.2:
            win_prob -= 0.15
        elif 0.05 <= raise_ratio <= 0.15:
            win_prob -= 0.075
        else:
            win_prob += 0.05

        return max(0, min(1, win_prob))

    def take_bet(self, player, amount):
        bet_amount = player.bet(amount)
        self.pot += bet_amount
        if bet_amount > self.current_bet:
            self.current_bet = bet_amount

    def betting_round(self):
        num_players = len(self.players)
        threshold_high = 100 * (num_players - 1) / num_players / 100

        # Ask for opponent betting information once
        opp_bet = int(input("Enter opponent's bet: "))
        opp_money = int(input("Enter opponent's remaining money: "))

        for player in self.players:
            win_prob = self.calculate_win_probability(player, opp_bet, opp_money)
            print(f"{player.name}'s turn. Adjusted Win Probability: {win_prob:.2f}, Current bet to match: {self.current_bet}")

            if win_prob > threshold_high:
                bet_amount = int(0.2 * self.pot)
                print(f"{player.name} raises by 20% of the pot ({bet_amount})")
            elif 0.6 <= win_prob <= threshold_high:
                bet_amount = int(0.05 * self.pot)
                print(f"{player.name} raises by 5% of the pot ({bet_amount})")
            elif 0.4 <= win_prob < 0.6:
                bet_amount = self.current_bet
                print(f"{player.name} calls the bet ({bet_amount})")
            else:
                print(f"{player.name} folds.")
                continue

            self.take_bet(player, bet_amount)
            print(f"{player.name} bets {bet_amount}. Remaining money: {player.money}")

        for player in self.players:
            player.reset_bet()

    def show_player_status(self):
        for player in self.players:
            print(f"{player.name} - Money: {player.money}, Cards: {player.cards}, Total Bet: {player.total_bet}")

# Example of game setup and execution
if __name__ == "__main__":
    players = ["Alice"]
    game = PokerGame(players)

    game.betting_round()
    game.show_player_status()


# Example of game setup and execution
if __name__ == "__main__":
    players = ["Alice"]
    game = PokerGame(players)

    game.betting_round()
    game.show_player_status()

!pip install eval7
import eval7
